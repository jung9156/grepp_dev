# LU 분해

### 행렬 분해

숫자의 인수분해는 숫자를 여러 숫자의 곱으로 분해 하여 표현

- 분수의 약분
- 두 수의 최대공약수, 최소공배수 구하기 등에 이용 가능

마찬가지로 행렬도 행렬분해 한 상태로 가지고 있으면 여러모로 계산이 편하다.

- LU 분해
- QR 분해
- 특이값 분해(SVD)



#### LU분해는 주어진 행렬을 아래의 형태를 가지는 두 행렬의 곱으로 나누는 행렬분해.

#### A = L x U

L - Lower triangular matrix(하삼각행렬)

U - upper triangular matrix(상삼각행렬)

LU분해의 응용

1. Ax = b
2. (LU)x = b
3. L(Ux) = b
4. Ly = b(단, Ux = y)

#### 4번까지 진행했을 때, 

Ly = b(L은 하삼각행렬) -> 전방대치법으로 y구하기

Ux = y(U는 상삼각행렬) - > 후방대치법으로 x 구하기



#### LU 분해는 가우스 소거법의 forward elimination(전방소거법)을 행렬로 코드와 한 것

##### A = PLU

- L : 행렬 A를 전방소거하는데 쓰인 replacement와 scaling에 대한 EORs를 기록해 둔 행렬
- U : 행렬 A를 전방소거한 후 남은 upper triangular matrix(상삼각행렬)
- P : 행렬 A를 전방소거하는데 쓰인 interchange에 대한 EROs를 기록해 둔 행렬(옵션)



#### LU분해 사용 이유

- 수치적 안정성 - 선형시스템 Ax = b의 해를 역행렬 A^-1를 이용해 직접 구하는 것 보다 PLU 분해를 이용하는 것이 좀 더 수치적으로 안정적이다.
- b가 자주 업데이트 되는 경우 - 선형시스템 Ax = b에서 행렬 A는 고정되어 있고 b가 자주 변하는 문제가 종종 있습니다. 이런 경우, 행렬 A를 미리 PLU로 분해해 둔다면, b가 업데이트될 때마다 선형시스템의 해 x를 실시간으로 구할 수 있다.



### 행렬연산과 선형조합

`행렬(matrix)`은 직사각형 구조에 숫자들을 담아놓은 구조. 각 숫자들은 행렬의 `요소(entry)`라 부른다.

[3	1

1	-2

2	-4]

는 3행과 2열로 이루어진 3 x 2 행렬

[2	1	0 -3]

은 행벡터(하나의 행으로 이루어진 행렬)

[1

3]

은 열벡터(하나의 열로 이루어진 행렬)

1x1행렬

[2]

는 스칼라 라고 한다.



##### 주요 표기법

- 행렬 A의 각 (i, j) - 요소는 a<sub>ij</sub>로 나타낸다.
- 행렬 A를 간략히 표기할 떄는 A = [a<sub>ij</sub>] 로 나타낸다.
- 행렬 A의 크기가 중요할 경우 A = [a<sub>ij</sub>]<sub>m x n</sub> 로 나타낸다.



전치행렬(transpose matrix) A<sup>T</sup>는 A의 행을 열로, A의 열을 행으로 가지는 n x m행렬이다.

- A(<sup>T</sup>)<sub>ij</sub> = (A)<sub>ji</sub>



벡터는 아래의 x와 같이 볼드체 소문자로 표기한다.

**x** = [x1

​		x2

​		x3

​		x4]

##### 주요 표기법

- 벡터라고 하면 일반적으로 열벡터(column vector)를 말한다.
- n - 벡터는 n개의 스칼라(scalar로 구성된 벡터를 말한다.



행렬의 모든 요소가 0이면, 해당 행렬을 `영행렬(zero matrix)`라 하고 *O*으로 표기한다.

A + O = O + A = A

영행렬은 숫자의 0과 같은 존재로 행렬합에 대한 항등원 역할을 한다.

##### 행렬의 합

두 행렬 A와 B는 행과 열의 개수가 모두 같을 때 성립하며, 각 (i, j) - 요소의 합으로 정의된다.



##### 정방행렬(Square Matrix)

행과 열의 개수가 모두 n인 정사각형 모양의 행렬을 `n차 정방행렬(squzre matrix)`라 한다.

특, a<sub>ij</sub> (i = 1, 2, ..., n)를 행렬 An의 `main diagonal(주대각선)`이라 한다.



주대각선이 1이고 나머지 요소는 모두 0인 n차 정방행렬을 `항등행렬(identity matrix)`라 한다.

항등행렬은 숫자의 1과 같은 존재로 행렬곱에 대한 항등원 역할을 한다.



### 행렬의 곱

m x r 행렬 A = [a<sub>ij</sub>]와 r x n 행렬 B = [b<sub>ij</sub>]가 있을 때, 두 행렬의 곱 AB는 아래와 같은 m x n 행렬 C = [c<sub>ij</sub>]

c<sub>ij</sub> = a<sub>i1</sub>b<sub>1j</sub> + a<sub>i2</sub>b<sub>2j</sub> + ... + a<sub>in</sub>b<sub>nj</sub>

##### 행렬의 곱에서 중요사항

- 행렬 C의 각 요소 c<sub>ij</sub>는 '곱의 왼쪽 행렬 A의 i번째 행벡터' 와 '곱의 오른쪽 행렬 B의 j번째 열벡터'의 내적(inner product)다.
  - 따라서, 두 행렬의 곱 AB에 대해 A의 열 개수와 B의 행 개수는 일치해야 한다.
  - 일반적으로 ~~AB = BA~~ 이다.(AB와 BA가 같지 않다.)
- 행렬의 곱은 병렬처리(parallel processing)으로 가속할 수 있다.



#### 스칼라

스칼라는 숫자 하나로 구성되어 있다.

- 7
- [7]
- [7]<sub>1x1</sub>

벡터는 여러 숫자가 일열로 늘어선 구조이다.

[1

 2

 3

 4]

이 벡터를 행렬로 표현하면 다음과 같이 여러 모양의 행렬로 표현할 수 있다.

[1	2

3	 4]<sub>2 x 2</sub>

[1	2	3	4]<sub>1 x 4</sub>

등등



행렬은 사각형 구조에 여러 숫자가 행과 열로 늘어선 구조이다.

[1	2	3

 4	5	6]<sub>2 x 3</sub>

이 행렬은 다음과 같이 6-벡터로 표현할 수 있다.

[1

 2

 3

 4

 5

 6]

`행렬을 벡터로 변환할 때, 행부터 혹은 열부터 읽을 것인지는 응용문제에 따라 결정한다.`



텐서(tensor)는 스칼라, 벡터, 행렬을 아우르는 개념이다. 숫자가 늘어설 수 있는 방향이 k개면 k-텐서로 부른다.

- 0-텐서 : 스칼라
- 1-텐서 : 벡터
- 2-텐서 : 행렬

##### 행렬 T의 각 요소 **p**가 벡터라면, T는 3-텐서

3-텐서의 대표적인 예는 컬러영상이다. **p**<sub>(ij)</sub>가 3-벡터이면 RGB 영상을, 4-벡터이면 RGBA 영상을 나타낸다고 볼 수 있다.



#### 분할행렬(partitioned Matrix)

행렬을 조각( partition) 단위로 분할하여 생각해도 무방하다. 이런 관점에서 행렬은 부분행렬(submatrix)로 이루어진 직사각형 구조로 확장해서 생각할 수 있다. 이렇게 행렬을 구조적으로 보는 방법을 `분할행렬(partitioned matrix)` 또는 `블록행렬(block matrix)`라



##### 분할행렬로 행렬의 곱 이해하기

두 행렬의 곱 AB = C를 matrix-column vector products로 볼 수 있다.

AB = A[b<sub>1</sub>	b<sub>2</sub>	...	b<sub>n</sub>] = [Ab<sub>1</sub>	Ab<sub>2</sub>	Ab<sub>n</sub>] = C



두 행렬의 곱 AB = C를 row vector-matrix products로도 볼 수 있다.

AB = [b<sub>1</sub>		B = C

​	      b<sub>2</sub>

  		...

  		b<sub>n</sub>]



#### 선형조합(Linear Combination): Ax는 A의 열벡터에 대한 선형조합

행렬을 구조적으로 바라보는 가장 효과적인 방법은 다음과 같다.

##### 행렬은 열벡터의 리스트이다.

A<sub>m x n</sub> 행렬의 요소 a<sub>ij</sub> 는 A의 i-번째 열벡터이다. 특히 각 열벡터는 m-벡터이기 때문에, m x n 행렬은 m-벡터가 n개 있다고 해석하면 된다.



#### 행렬 @ 벡터 연산을 구조적으로 보기

Ax는 행렬 A가 가지고 있는 열벡터의 선형조합

a의 j번째 벡터를 x의 i번째 배

`Ax의 결과는 행렬 A가 가지고 있는 열벡터의 선형조합으로만 한계가 지어진다.`



##### 정리 - 선형시스템 Ax = b를 선형조합 관점에서 바라보기

행렬 A의 열벡터를 가중치합으로 선형조합할 때 벡터 b를 만들 수 있는 가중치 조합이 존재한다면,

선형시스템 Ax = b 의 해는 존재한다. 그 해는 가중치 x<sub>i</sub>들로 구성된 **x**이다.



##### 열공간(Column Space)

- 행렬 A의 `열벡터들에 대한 가능한 모든 선형조합의 결과`를 모아 집합으로 구성할 수 있을 것이다. 이런 집합을 column space(열공간)이라 하고, 다음과 같이 표기한다.
  - col(A)
- Consistent Linear System
  - 선형시스템 Ax = b가 해를 가지면, 다음을 만족한다.
  - **b** 는 col(A)의 속한다.
- Inconsistent Linear System
  - 선형시스템 Ax = b의 해가 없으면, 다음을 만족한다.
  - **b**는 col(A)에 속하지 않는다.



-> 행렬을 분해(열벡터로)하고, 선형시스템으로 표현해서 해가 있는지 혹은 없는지를 쉽게 판별할 수 있다.



### 좌표계(basis) 변환

벡터는 크기와 방향을 가진 물리량으로 다음과 같이 표현될 수 있습니다.

- 벡터의 물리적 표현(좌표계X)
  - v의 크기 : 화살표의 길이
  - v의 방향 : 화살표의 방향
- 벡터의 수학적 표현(좌표계O)
  - 벡터 v를 화살표로 표현한다.
  - 좌표계를 도입한 후, 벡터의 시작점을 원점으로 맞추고, 끝점의 위치를 벡터 v의 수학적 표현으로 정의
    - v의 크기 : 화살표의 길이를 계산
    - v의 방향: 화살표의 방향을 벡터로 표현

#### 좌표계

만일 두 벡터 v<sub>1</sub>, v<sub>2</sub>를 이용해 새롭게 좌표계를 만든다면 v의 좌표값은 무엇일까?

새로운 좌표계를 만든다는 말은 어떤 벡터 v에 도착하기 까지의 과정을 오롯이 v<sub>1</sub>과 v<sub>2</sub>를 몇번 사용하여 도착했는지로 표현한다는 의미입니다.

즉, v<sub>1</sub>과 v<sub>2</sub>를 이용해 만든 새로운 좌표계에서 v의 좌표값은 (4,3)이라 해야 합니다.

- 4v<sub>1</sub> + 3v<sub>2</sub> = v
- 4v<sub>1</sub> + 3v<sub>2</sub> = 8x + 6.5y
  - 새로운 좌표계v 의 표현과 기존 xy좌표계



선형시스템 문제와 좌표계 변환

Ax = b

- 우항 - 표준좌표계에서 어떤 벡터의 좌표값은 b이다.
- 좌항 - A의 열벡터들을 기준(기저 - basis)로 가지는 좌표계에서는 동일 벡터의 좌표값은 x이다.



역행렬을 이용한 선형시스템의 해를 구하는 문제 역시, 

- 우항 : 표준좌표계에서 어떤 벡터의 좌표값은 x이다.
- 좌항 :  A<sup>-1</sup>의 열벡터들을 기저(basis)로 가지는 좌표계에서는 동일 벡터의 좌표값은 b이다.

Ax = b -> A<sup>-1</sup>b = x

에서 x를 표준좌표계로 보고 해를 구하면 같은 결과가 나온다.



##### 정리

행렬은 좌표계, 벡터는 좌표 값.

임의의 v는 다양한 좌표계에서 표현될 수 있다.



### 선형변환(Linear Transformation)

##### 함수 - 정의역의 원소를 공역의 원소로 매핑시켜줄 수 있는 룰(mapping rule)

- 정의역(domain) : 입력이 정의된 집합
- 공역(codomain) : 출력이 정의된 집합
- 치역(range) : 실제 함수의 출력이 정의된 공역의 부분집합



##### 선형함수

만일 함수 f가 두 가지 조건을 만족하면 함수 f를 선형함수(linear function)이라고 합니다.

- f(x + y) = f(x) + f(y)
- f(cx) = cf(x)  (단, c는 임의의 스칼라)



##### 변환(Transformation)

함수의 입력이 n-벡터이고 출력이 m-벡터인 함수 T를 생각해 봅시다. 이와 같이 함수의 입출력이 벡터인 함수를 `변환(Transformation)`라 합니다.

특히 n = m인 경우, 해당 변환을 `연산자(operator)`라고 합니다.



ex: 28 x 28 해상도의 손글씨 숫자 영상을 그레이스케일로 받아, 0부터 9까지의 어떤 숫자가 적혀있는지 알아내는

MNIST 손글씨 인식 문제는 비선형 변환이다.

- T = R<sup>28 x 28</sup> -> R<sup>10</sup>



##### 행렬변환(Matrix Transformation)

m x n 행렬 A에 대해 Ax는 n-벡터를 입력으로 받아 m-벡터를 출력으로 내는 변환

T<sub>A</sub>(x) = Ax로 볼 수 있다. 이 변환은 행렬이 정의하기 때문에 `행렬변환(Matrix Transformation)`이라 한다.

##### 정리 - m x n 행렬은 n-벡터를 입력으로 받아 m-벡터를 출력으로 내는 `선형변환`이며, 임의의 선형변환은 행렬로 표현가능 하다. 즉, `행렬은 선형변환의 구현체` 입니다.



#### 표준행렬(standard matrix) 선형변환 코딩하기

1. 구현하고자 하는 기능(function)의 입력과 출력이 벡터로 정의되는지 확인
2. 구현하고자 하는 기능이 선형인지 확인한다.
3. 입력이 n-벡터이고, 출력이 m-벡터이면 mxn `표준행렬을 구성`한다.

##### 표준행렬 구하기

- n-차원 표준기저벡터 {e<sub>1</sub>, e<sub>2</sub>, ... e<sub>n</sub>}을 생각한다.
- 각 n-차원 표준기저벡터 e<sub>i</sub>에 대해, 우리가 원하는 기능을 동작시켜 얻은 결과인 m-차원 벡터(T(e<sub>i</sub>))를 표준행렬의 각 열에 적는다.



x축(1, 0) y축(0, 1)을 각각 동작시켜 얻은 결과를 각 열에 적으므로 선형변환 코딩을 할 수 있다.(2주차 2일-6강 마지막 부분)